

# 9.7: Compute Binary Tree Nodes in Order of Increasing Depth#

*   If each node in a binary tree has a depth indicating its distance from the root
*   Given a binary tree, return an array consisting of the keys at the same level
*   Keys should appear in the order of the corresponding nodes' depths, breaking ties from left to right

`vector<vector<int>> BSTDepthOrder(const unique_ptr<BinaryTreeNode<int>>& tree)`

### Code Here ###

```

//HI

```

---



# 10.1 Test if a Binary Tree is Height Blanaced #

*   Given the root of a binary tree
*   check whether or not the tree is height balanced
*   a tree is height balanced if the difference in the height of its left and right subtrees is at most one

`boolean IsHeightBalanced(unique_ptr<BinaryTreeNode<int>>& tree)`

### Code Here ###
```

// Hi

```

# 12.4 Compute The integer Square Root #

*  Given a none neegative integer
*  return the largest integer whose square is less than or equal to the given Integer
*  ex) if the input is 16, return 4. If the input is 300, return 17. Because 17 squared == 289 and 18 squared is 324 (too large)

`vector<vector<int>> BSTDepthOrder(const unique_ptr<BinaryTreeNode<int>>& tree)`

### Code Here ###

```

//HI

```

---

13.2

`vector<vector<int>> BSTDepthOrder(const unique_ptr<BinaryTreeNode<int>>& tree)`

### Code Here ###

```

//HI

```

---
